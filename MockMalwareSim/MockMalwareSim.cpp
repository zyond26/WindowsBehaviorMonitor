// MockMalwareSim.cpp : Simulates RWX memory behavior for testing EDR
// This program allocates memory with PAGE_EXECUTE_READWRITE to simulate malicious behavior

#include <Windows.h>
#include <iostream>
#include <iomanip>

int main()
{
    std::cout << "========================================\n";
    std::cout << "  Mock Malware Simulator (RWX Memory)\n";
    std::cout << "========================================\n\n";

    // Get and display current Process ID
    DWORD pid = GetCurrentProcessId();
    std::cout << "Process ID: " << pid << std::endl;
    std::cout << "Process Name: MockMalwareSim.exe\n\n";

    // Allocate 1MB memory with RWX protection
    const SIZE_T memorySize = 1024 * 1024; // 1MB
    LPVOID allocatedMemory = VirtualAlloc(
        nullptr,                        // Let system choose the address
        memorySize,                     // 1MB
        MEM_COMMIT | MEM_RESERVE,       // Commit and reserve
        PAGE_EXECUTE_READWRITE          // RWX protection (0x40)
    );

    if (allocatedMemory == nullptr)
    {
        std::cerr << "ERROR: VirtualAlloc failed! Error code: " << GetLastError() << std::endl;
        return 1;
    }

    std::cout << "SUCCESS: Allocated 1MB memory with RWX protection\n";
    std::cout << "Base Address: 0x" << std::hex << std::uppercase 
              << reinterpret_cast<ULONG_PTR>(allocatedMemory) << std::endl;
    std::cout << "Region Size: 0x" << memorySize << " bytes (1MB)\n";
    std::cout << "Protection: PAGE_EXECUTE_READWRITE (0x40)\n\n";

    // Write dummy payload to the allocated memory
    const char* payload = "This is a test payload for EDR detection simulation!";
    size_t payloadLength = strlen(payload);
    memcpy(allocatedMemory, payload, payloadLength);

    std::cout << "Payload written to memory: \"" << payload << "\"\n\n";

    // Display memory information
    MEMORY_BASIC_INFORMATION mbi{};
    if (VirtualQuery(allocatedMemory, &mbi, sizeof(mbi)))
    {
        std::cout << "Memory Details:\n";
        std::cout << "  Base Address: 0x" << std::hex << reinterpret_cast<ULONG_PTR>(mbi.BaseAddress) << std::endl;
        std::cout << "  Allocation Base: 0x" << reinterpret_cast<ULONG_PTR>(mbi.AllocationBase) << std::endl;
        std::cout << "  Region Size: 0x" << mbi.RegionSize << std::endl;
        std::cout << "  State: " << (mbi.State == MEM_COMMIT ? "MEM_COMMIT" : "OTHER") << std::endl;
        std::cout << "  Type: " << (mbi.Type == MEM_PRIVATE ? "MEM_PRIVATE" : "OTHER") << std::endl;
        std::cout << "  Protect: 0x" << mbi.Protect << std::endl;
    }

    std::cout << "\n========================================\n";
    std::cout << "This process will stay running.\n";
    std::cout << "Use the ProcessManager scanner to detect this RWX memory.\n";
    std::cout << "Press ENTER to exit and clean up...\n";
    std::cout << "========================================\n\n";

    // Keep process alive until user presses Enter
    std::cin.get();

    // Clean up
    if (VirtualFree(allocatedMemory, 0, MEM_RELEASE))
    {
        std::cout << "\nMemory successfully freed. Exiting...\n";
    }
    else
    {
        std::cerr << "\nWARNING: Failed to free memory! Error code: " << GetLastError() << std::endl;
    }

    return 0;
}
